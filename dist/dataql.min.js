/*jshint -W030 */

;(function(global){
  'use strict';

  /**
   * DataQL constructor
   */
  function DQ(){
    var self = this;

    self._tables = [];
    self._transforms = [];
    self._result = [];
    self._fetched = false;
  }

  global.__ = '__';

  /**
   * Comparators
   */
  DQ.operators = {};

  // Equal
  DQ.operators['='] = function(operand1, operand2) {
    return operand1 == operand2; // jshint ignore:line
  };

  // Greater than
  DQ.operators['>'] = function(operand1, operand2) {
    return operand1 > operand2;
  };

  // Lower than
  DQ.operators['<'] = function(operand1, operand2) {
    return operand1 < operand2;
  };

  // Greater or equal than
  DQ.operators['>='] = function(operand1, operand2) {
    return operand1 >= operand2;
  };

  // Lower or equal than
  DQ.operators['<='] = function(operand1, operand2) {
    return operand1 <= operand2;
  };

  /**
   * Get operator from string
   */
  DQ.prototype._getCmp = function(cmp) {
    if(!_.isFunction(DQ.operators[cmp]))
      throw new Error('Operator not supported');
    return DQ.operators[cmp];
  };

  /**
   * Join tables
   */
  DQ.prototype._join = function(resources, result, params){
    var self = this;
    var toJoin = [];
    var cmp = self._getCmp(params.where.cmp);

    if(_.has(resources, params.table)){
      toJoin = resources[params.table].records;
    }

    return _.map(result, function(resultRecord){

      // Get all the matched elements on the join table
      var matched = _.filter(toJoin, function(joinRecord){
        return cmp(
          resultRecord[params.where.left],
          joinRecord[params.where.right]
        );
      });

      // Extend results with the join table.
      // Like other sql databases we only use the first
      // matched element.
      return _.extend(resultRecord, _.first(matched));
    });
  };

  /**
   * Set table
   */
  DQ.prototype._set = function(resources, result, params){
    if(!_.has(resources, params.table))
      throw new Error('Table not fetched. Fetch and name the table before set.');
    return _.clone(resources[params.table].records);
  };


  /**
   * Filter rows (aka. sql where)
   */
  DQ.prototype._filter = function(resources, result, params){
    var self = this;
    var cmp = self._getCmp(params.where.cmp);

    return _.filter(result, function(record){
      return cmp(record[params.where.left], params.where.right);
    });
  };

  /**
   * Limit
   */
  DQ.prototype._limit = function(resources, result, params){
    return result.slice(params.start, params.start + params.numRows);
  };

  /**
   * Sort by order
   */
  DQ.prototype._sort = function(resources, result, params){
    var order = (params.order === 'desc') ? false : true;
    var field = params.field;
    return _.sortByOrder(result, field, order);
  };

  /**
   * Rename a column
   */
  DQ.prototype._rename = function(resources, result, params){
    return _.map(result, function(record){
      record[params.newName] = record[params.oldName];
      return _.omit(record, params.oldName);
    });
  };

  /**
   * Delete a column
   */
  DQ.prototype._delete = function(resources, result, params){
    return _.map(result, function(record){
      return _.omit(record, params.field);
    });
  };

  /**
   * Add columns or rows
   */
  DQ.prototype._add = function(resources, result, params){
    var self = this;
    var method = (params.type === 'column') ?
      'addColumn' :
      'addRow' ;

    return self['_' + method](resources, result, params);
  };

  /**
   * Add column
   */
  DQ.prototype._addColumn = function(resources, result, params){
    var self = this;
    var values = self._range(resources, result, params.from);

    return _.map(result, function(record, index){
      record[params.field] = values[index];
      return record;
    });
  };

  /**
   * Add row
   */
  DQ.prototype._addRow = function(resources, result, params){
    var self = this;
    var values = self._range(resources, result, params.from);
    var fields = _.first(result).keys();

    result.push(self.toMap(Array.from(fields), values));

    return result;
  };

  /**
   * Group by field
   */
  DQ.prototype._groupBy = function(resources, result, params){
    var grouped = _.values(_.groupBy(result, params.field));
    return _.map(grouped, function(record){
      return record[0];
    });
  };

  /**
   * Format to any available output
   */
  DQ.prototype._format = function(resources, result, params){
    return DQ.fmt['to' + params.format.toUpperCase()](result);
  };

  /**
   * Save the output as any available format.
   */
  DQ.prototype._download = function(resources, result, params){
    var type = {type: params.type || 'text/plain;charset=utf-8'};
    var blob = new Blob([result], type);
    saveAs(blob, params.filename || 'download.txt');
    return result;
  };

  /**
   * Create a vector either from a row or a column.
   * Unlike other function this recieve only resources
   * and params as parameters because it's a helper
   * function and intended to be piped.
   */
  DQ.prototype._range = function(resources, result, params){
    var self = this;
    var method = (params.type === 'column') ?
      'vectorFromColumns' :
      'vectorFromRows' ;

    return self['_' + method](resources, params);
  };

  /**
   * Create a vector from a columns
   */
  DQ.prototype._vectorFromColumns = function(resources, params){
    // TODO: Add match pattern to match column names.
    var record = resources[params.table].records[params.row];
    var result = [];
    var index = 0;

    // Loop over the records and store those
    // satisfy the condition
    record.forEach(function(value, key){
      if(index >= params.from || index <= params.to){
        result.push(value);
      }
      ++index;
    });
    return result;
  };

  /**
   * Create a vector from row
   */
  DQ.prototype._vectorFromRows = function(resources, params){
    var records = resources[params.table].records;

    return _.reduce(records, function(acum, record, index) {
      if(index >= params.from && index <= params.to)
        acum.push(record[params.field]);
      return acum;
    }, []);
  };

  /**
   * Run transforms
   */
  DQ.prototype._runTransforms = function(){
    var self = this;

    _.each(self._transforms, function(T){
      var engine = _.capitalize(T.engine) || 'Native';
      self._result = self['_run' + engine](self._resources, self._result, T);
    });

    return self;
  };

  /**
   * Run lodash
   */
  DQ.prototype._runLodash = function(resources, result, T){
    var self = this;
    return _[T.method].apply(result,[result].concat(T.args) || []);
  };

  /**
   * Run native
   */
  DQ.prototype._runNative = function(resources, result, T){
    var self = this;

    return self['_' + T.method](
      resources,
      result,
      _.omit(T, 'method')
    );
  };

  /**
   * Get a backend from its string representation.
   * @param  {String} backend  Backend string representation.
   */
  DQ.prototype._backendFromString = function(backend) {
    return _.findWhere(DQ.backends, {__type__: backend});
  };

  /**
   * Fetch all the tables and place them into sources
   */
  DQ.prototype._fetchResources = function(){
    var self = this;
    var promises = [];

    _.each(self._tables, function(table){
      var backend = self._backendFromString(table.backend);

      if(!backend) throw new Error('Backend not found');
      promises.push(backend.fetch(table));
    });

    return Promise.all(promises);
  };


  /****************************
  *                           *
  *     Field transforms      *
  *                           *
  ****************************/

  /**
   * Transform field
   */
  DQ.prototype._transformField = function(result, params, predicate){
    return _.map(result, function(record){
      return _.mapValues(record, function(value, key){
        return (params.field === key) ?
          predicate.apply(value, [value].concat(params.args)) :
          value ;
      });
    });
  };

  /**
   * Trim
   */
  DQ.prototype._trim = function(resources, result, params){
    var self = this;
    return self._transformField(result, params, _.trim);
  };

  /**
   * Cast
   */
  DQ.prototype._cast = function(resources, result, params){
    var self = this;
    return self._transformField(result, params, DQ.cast);
  };

  /**
   * Substring
   */
  DQ.prototype._substr = function(resources, result, params){
    var self = this;
    return self._transformField(result, params, DQ.substr);
  };

  /**
   * Truncates string if itâ€™s longer than the given maximum string length.
   */
  DQ.prototype._trunc = function(resources, result, params){
    var self = this;
    return self._transformField(result, params, _.trunc);
  };

  /**
   * Capitalize
   */
  DQ.prototype._capitalize = function(resources, result, params){
    var self = this;
    return self._transformField(result, params, _.capitalize);
  };

  /**
   * Clear
   */
  DQ.prototype._clear = function(){
    var self = this;
    self._result.length = 0;
  };


  /**********************
  *                     *
  *     PUBLIC API      *
  *                     *
  **********************/

  /**
   * Define the tables you want to use.
   */
  DQ.prototype.tables = function(){
    var self = this;

    if(self instanceof DQ){

      // Fetched resources indexed by name
      self._resources = {};

      // Tables to retrieve
      self._tables = _.toArray(arguments);
      return self;
    } else {
      var ql = new DQ();
      return ql.tables.apply(ql, _.toArray(arguments));
    }

    return self;
  };

  /**
   * Queue a set transform
   */
  DQ.prototype.set = function(resource){
    this._transforms.push({
      method: 'set',
      table: resource
    });
    return this;
  };

  /**
   * Queue a rename transform
   */
  DQ.prototype.rename = function(oldName, newName){
    this._transforms.push({
      oldName: oldName,
      newName: newName,
      method: 'rename',
    });
    return this;
  };

  /**
   * Add an operation to the queue.
   */
  DQ.prototype.transforms = function(transforms){
    var self = this;
    if(!arguments.length) return self._transforms;
    self._clear();
    self._transforms = transforms;
    if(self._fetched) {
      self._runTransforms();
      return _.clone(self._result);
    }
    return self;
  };

  /**
   * Fetch resources
   */
  DQ.prototype._fetch = function(transforms){
    var self = this;
    var tableNames = _.pluck(self._tables, 'as');
    var dfd = new DQ.Deferred();

    self._fetchResources().then(function(data){
      self._fetched = true;
      self._resources = _.zipObject(tableNames, data);
      self._runTransforms();
      dfd.resolve(self);
    });

    return dfd.promise;
  };

  /**
   * Creates a serialized version
   * of the current query
   */
  DQ.prototype.serialize = function(){
    var self = this;
    return JSON.stringify(self.toObject());
  };

  /**
   * Load a serialized version
   * of the current query
   */
  DQ.prototype.load = function(serialized){
    var self = this;
    var obj = (_.isString(serialized)) ? JSON.parse(serialized) : serialized;
    self._tables = obj.tables;
    self._transforms = obj.transforms;
    return self;
  };

  /**
   * Creates an object version
   * of the current query
   */
  DQ.prototype.toObject = function(){
    var self = this;

    var obj = {
      tables: self._tables,
      transforms: self._transforms
    };

    return obj;
  };

  /**
   * Perform the query.
   */
  DQ.prototype.commit = function(cb){
    var self = this;
    var tableNames = _.pluck(self._tables, 'as');

    self._fetchResources()
    .then(function(data){
      self._fetched = true;
      self._resources = _.zipObject(tableNames, data);
      self._runTransforms();
      cb(_.clone(self._result));
    });

    return self;
  };

  // Expose dataql constructor
  global.DQ = global.DQ = DQ;
  global.tables = DQ.prototype.tables;
})(window);;/*global DQ: true*/
/*global CSV: true*/

var CSV = {};

(function(my) {
  'use strict';
  my.__type__ = 'csv';


  my.fetch = function(dataset) {
    var dfd = new DQ.Deferred();
    if (dataset.file) {
      var reader = new FileReader();
      var encoding = dataset.encoding || 'UTF-8';
      reader.onload = function(e) {
        var out = my.extractFields(my.parse(e.target.result, dataset), dataset);
        out.useMemoryStore = true;
        out.metadata = {
          filename: dataset.file.name
        };
        dfd.resolve(out);
      };
      reader.onerror = function (e) {
        console.log('Failed to load file. Code: ' + e.target.error.code);
      };
      reader.readAsText(dataset.file, encoding);
    } else if (dataset.data) {
      var out = my.extractFields(my.parse(dataset.data, dataset), dataset);
      out.useMemoryStore = true;
      dfd.resolve(out);
    } else if (dataset.url) {
      DQ.ajax(dataset.url).get().then(function(data) {
        var out = my.extractFields(my.parse(data, dataset), dataset);
        out.useMemoryStore = true;
        dfd.resolve(out);
      });
    }
    return dfd.promise;
  };

  // Convert array of rows in { records: [ ...] , fields: [ ... ] }
  // @param {Boolean} noHeaderRow If true assume that first row is not a header (i.e. list of fields but is data.
  my.extractFields = function(rows, noFields) {
    if (noFields.noHeaderRow !== true && rows.length > 0) {
      var fields = rows[0];

      return {
        fields: fields,
        records: _.map(rows.slice(1), _.partial(_.zipObject, fields))
      };
    } else {
      return {
        records: rows
      };
    }
  };

  my.normalizeDialectOptions = function(options) {
    // note lower case compared to CSV DDF
    var out = {
      delimiter: ',',
      doublequote: true,
      lineterminator: '\n',
      quotechar: '"',
      skipinitialspace: true,
      skipinitialrows: 0
    };
    for (var key in options) {
      if (key === 'trim') {
        out.skipinitialspace = options.trim;
      } else {
        out[key.toLowerCase()] = options[key];
      }
    }
    return out;
  };

  // ## parse
  //
  // For docs see the README
  //
  // Heavily based on uselesscode's JS CSV parser (MIT Licensed):
  // http://www.uselesscode.org/javascript/csv/
  my.parse= function(s, dialect) {
    // Get rid of any trailing \n
    s = chomp(s);

    var options = my.normalizeDialectOptions(dialect);

    var cur = '', // The character we are currently processing.
      inQuote = false,
      fieldQuoted = false,
      field = '', // Buffer for building up the current field
      row = [],
      out = [],
      i,
      processField;

    processField = function (field) {
      if (fieldQuoted !== true) {
        // If field is empty set to null
        if (field === '') {
          field = null;
        // If the field was not quoted and we are trimming fields, trim it
        } else if (options.skipinitialspace === true) {
          field = trim(field);
        }

        // Convert unquoted numbers to their appropriate types
        if (rxIsInt.test(field)) {
          field = parseInt(field, 10);
        } else if (rxIsFloat.test(field)) {
          field = parseFloat(field, 10);
        }
      }
      return field;
    };

    for (i = 0; i < s.length; i += 1) {
      cur = s.charAt(i);

      // If we are at a EOF or EOR
      if (inQuote === false && (cur === options.delimiter || cur === '\n')) {
        field = processField(field);
        // Add the current field to the current row
        row.push(field);
        // If this is EOR append row to output and flush row
        if (cur === '\n') {
          out.push(row);
          row = [];
        }
        // Flush the field buffer
        field = '';
        fieldQuoted = false;
      } else {
        // If it's not a quotechar, add it to the field buffer
        if (cur !== options.quotechar) {
          field += cur;
        } else {
          if (!inQuote) {
            // We are not in a quote, start a quote
            inQuote = true;
            fieldQuoted = true;
          } else {
            // Next char is quotechar, this is an escaped quotechar
            if (s.charAt(i + 1) === options.quotechar) {
              field += options.quotechar;
              // Skip the next char
              i += 1;
            } else {
              // It's not escaping, so end quote
              inQuote = false;
            }
          }
        }
      }
    }

    // Add the last field
    field = processField(field);
    row.push(field);
    out.push(row);

    // Expose the ability to discard initial rows
    if (options.skipinitialrows) out = out.slice(options.skipinitialrows);

    return out;
  };

  my.objectToArray = function(dataToSerialize) {
    var a = [];
    var fieldNames = [];
    var ii;
    var jj;

    for (ii = 0; ii < dataToSerialize.fields.length; ii++) {
      fieldNames.push(dataToSerialize.fields[ii].id);
    }
    a.push(fieldNames);
    for (ii = 0; ii < dataToSerialize.records.length; ii++) {
      var tmp = [];
      var record = dataToSerialize.records[ii];
      for (jj = 0; jj < fieldNames.length; jj++) {
        tmp.push(record[fieldNames[jj]]);
      }
      a.push(tmp);
    }
    return a;
  };

  // ## serialize
  //
  // See README for docs
  //
  // Heavily based on uselesscode's JS CSV serializer (MIT Licensed):
  // http://www.uselesscode.org/javascript/csv/
  my.serialize = function(dataToSerialize, dialect) {
    var a = null;
    if (dataToSerialize instanceof Array) {
      a = dataToSerialize;
    } else {
      a = my.objectToArray(dataToSerialize);
    }
    var options = my.normalizeDialectOptions(dialect);

    var cur = '', // The character we are currently processing.
      field = '', // Buffer for building up the current field
      row = '',
      out = '',
      i,
      j,
      processField;

    processField = function (field) {
      if (field === null) {
        // If field is null set to empty string
        field = '';
      } else if (typeof field === 'string' && rxNeedsQuoting.test(field)) {
        if (options.doublequote) {
          field = field.replace(/"/g, '""');
        }
        // Convert string to delimited string
        field = options.quotechar + field + options.quotechar;
      } else if (typeof field === 'number') {
        // Convert number to string
        field = field.toString(10);
      }

      return field;
    };

    for (i = 0; i < a.length; i += 1) {
      cur = a[i];

      for (j = 0; j < cur.length; j += 1) {
        field = processField(cur[j]);
        // If this is EOR append row to output and flush row
        if (j === (cur.length - 1)) {
          row += field;
          out += row + '\n';
          row = '';
        } else {
          // Add the current field to the current row
          row += field + options.delimiter;
        }
        // Flush the field buffer
        field = '';
      }
    }

    return out;
  };

  var rxIsInt = /^\d+$/,
    rxIsFloat = /^\d*\.\d+$|^\d+\.\d*$/,
    // If a string has leading or trailing space,
    // contains a comma double quote or a newline
    // it needs to be quoted in CSV output
    rxNeedsQuoting = /^\s|\s$|,|"|\n/,
    trim = (function () {
      // Fx 3.1 has a native trim function, it's about 10x faster, use it if it exists
      if (String.prototype.trim) {
        return function (s) {
          return s.trim();
        };
      } else {
        return function (s) {
          return s.replace(/^\s*/, '').replace(/\s*$/, '');
        };
      }
    }());

  function chomp(s) {
    if (s.charAt(s.length - 1) !== '\n') {
      // Does not end with \n, just return string
      return s;
    } else {
      // Remove the \n
      return s.substring(0, s.length - 1);
    }
  }
}(CSV));

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.CSV = CSV;
;/*global DQ: true*/

var GDocs = {};

(function(my) {
  'use strict';
  my.__type__ = 'gdocs';

  // Fetch data from a Google Docs spreadsheet.
  //
  // For details of config options and returned values see the README in
  // the repo at https://github.com/Recline/backend.gdocs/
  my.fetch = function(config) {
    var dfd = new DQ.Deferred();
    var urls = my.getGDocsApiUrls(config.url, config.worksheetIndex);

    // TODO cover it with tests
    // get the spreadsheet title
    (function () {
      var titleDfd = new DQ.Deferred();

      DQ.ajax(urls.spreadsheetAPI).get().then(function (d) {
        d = JSON.parse(d);
        titleDfd.resolve({
            spreadsheetTitle: d.feed.title.$t
        });
      }).catch(function(errObj) { titleDfd.reject(errObj); });

      return titleDfd.promise;
    }()).then(function (response) {

      // get the actual worksheet data
      DQ.ajax(urls.worksheetAPI).get().then(function(d) {
        d = JSON.parse(d);
        var result = my.parseData(d);
        var fields = _.map(result.fields, function(fieldId) {
          return {id: fieldId};
        });

        var metadata = _.extend(urls, {
          title: response.spreadsheetTitle + ' - ' + result.worksheetTitle,
          spreadsheetTitle: response.spreadsheetTitle,
          worksheetTitle  : result.worksheetTitle
        });
        dfd.resolve({
          metadata: metadata,
          records       : result.records,
          fields        : fields,
          useMemoryStore: true
        });
      });
    }).catch(function(errObj) { dfd.reject(errObj); });

    return dfd.promise;
  };

  // ## parseData
  //
  // Parse data from Google Docs API into a reasonable form
  //
  // :options: (optional) optional argument dictionary:
  // columnsToUse: list of columns to use (specified by field names)
  // colTypes: dictionary (with column names as keys) specifying types (e.g. range, percent for use in conversion).
  // :return: tabular data object (hash with keys: field and data).
  //
  // Issues: seems google docs return columns in rows in random order and not even sure whether consistent across rows.
  my.parseData = function(gdocsWorksheet, options) {
    options  = options || {};
    var colTypes = options.colTypes || {};
    var results = {
      fields : [],
      records: []
    };
    var entries = gdocsWorksheet.feed.entry || [];
    var key;
    var colName;
    // percentage values (e.g. 23.3%)
    var rep = /^([\d\.\-]+)\%$/;

    for(key in entries[0]) {
      // it's barely possible it has inherited keys starting with 'gsx$'
      if(/^gsx/.test(key)) {
        colName = key.substr(4);
        results.fields.push(colName);
      }
    }

    // converts non numberical values that should be numerical (22.3%[string] -> 0.223[float])
    results.records = _.map(entries, function(entry) {
      var row = {};

      _.each(results.fields, function(col) {
        var _keyname = 'gsx$' + col;
        var value = entry[_keyname].$t;
        var num;

        // TODO cover this part of code with test
        // TODO use the regexp only once
        // if labelled as % and value contains %, convert
        if(colTypes[col] === 'percent' && rep.test(value)) {
          num   = rep.exec(value)[1];
          value = parseFloat(num) / 100;
        }

        row[col] = value;
      });
      return row;
    });
    results.worksheetTitle = gdocsWorksheet.feed.title.$t;
    return results;
  };

  // Convenience function to get GDocs JSON API Url from standard URL
  //
  // @param url: url to gdoc to the GDoc API (or just the key/id for the Google Doc)
  my.getGDocsApiUrls = function(url, worksheetIndex) {
    // https://docs.google.com/spreadsheet/ccc?key=XXXX#gid=YYY
    var regex = /.*spreadsheet\/ccc\?.*key=([^#?&+]+)[^#]*(#gid=([\d]+).*)?/;
      // new style is https://docs.google.com/a/okfn.org/spreadsheets/d/16DayFB.../edit#gid=910481729
    var regex2 = /.*spreadsheets\/d\/([^\/]+)\/edit(#gid=([\d]+).*)?/;
    var matches = url.match(regex);
    var matches2 = url.match(regex2);
    var key;
    var worksheet;

    if (!!matches) {
        key = matches[1];
        // the gid in url is 0-based and feed url is 1-based
        worksheet = parseInt(matches[3]) + 1;
        if (isNaN(worksheet)) {
          worksheet = 1;
        }
    }
    else if (!!matches2) {
      key = matches2[1];
      worksheet = 1;
      if (isNaN(worksheet)) {
        worksheet = 1;
      }
    }
    else if (url.indexOf('spreadsheets.google.com/feeds') !== -1) {
        // we assume that it's one of the feeds urls
        key = url.split('/')[5];
        // by default then, take first worksheet
        worksheet = 1;
    } else {
      key = url;
      worksheet = 1;
    }
    worksheet = (worksheetIndex || worksheetIndex ===0) ? worksheetIndex : worksheet;

    return {
      worksheetAPI: 'https://spreadsheets.google.com/feeds/list/'+ key +'/'+ worksheet +'/public/values?alt=json',
      spreadsheetAPI: 'https://spreadsheets.google.com/feeds/worksheets/'+ key +'/public/basic?alt=json',
      spreadsheetKey: key,
      worksheetIndex: worksheet
    };
  };
}(GDocs));

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.GDocs = GDocs;;/*global DQ: true*/
/*global Inline: true*/

var Inline = {};

(function(my) {
  'use strict';
  my.__type__ = 'inline';

  my.fetch = function(dataset) {
    var dfd = new DQ.Deferred();
    dfd.resolve(dataset);
    return dfd.promise;
  };

}(Inline));

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.Inline = Inline;;/*global DQ: true*/

var Report = {};

(function(my) {
  'use strict';
  my.__type__ = 'report';

  my.fetch = function(dataset) {
    var dfd = new DQ.Deferred();
    var query = new DQ();

    query
    .load(dataset.report)
    .commit(function(data){
      var out = {};
      out.records = data;
      dfd.resolve(out);
    });

    return dfd.promise;
  };

}(Report));

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.Report = Report;;/*global DQ: true*/

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.JSON = {};

(function(my) {
  'use strict';
  my.__type__ = 'json';

  my.fetch = function(dataset) {
    var dfd = new DQ.Deferred();

    DQ.jsonp(dataset.url).then(function(data){
      var out = {};
      out.records = _.get(data, dataset.path);
      dfd.resolve(out);
    });

    return dfd.promise;
  };

}(DQ.backends.JSON));


;/*global DQ: true*/
/*jshint camelcase: false */

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.XLSX = {};

(function(my) {
  'use strict';
  my.__type__ = 'xlsx';

  my.fetch = function(dataset) {

    var dfd = new DQ.Deferred();
    DQ.ajax(dataset.url)
    .get({responseType: 'arraybuffer'})
    .then(function(d) {
      var out = {};
      var data = new Uint8Array(d);
      var arr = [];
      for(var i = 0; i !== data.length; ++i) arr[i] = String.fromCharCode(data[i]);
      var bstr = arr.join('');
      var workbook = XLSX.read(bstr, {type: 'binary' });
      out.fields = my.extractFields(workbook.Sheets[dataset.sheet]);
      out.records = my.extractData(workbook.Sheets[dataset.sheet], out.fields);
      dfd.resolve(out);
    });

    return dfd.promise;
  };

  my.extractFields = function(sheet){
    var headers = [];
    var range = XLSX.utils.decode_range(sheet['!ref']);
    var C, R = range.s.r;

    for(C = range.s.c; C <= range.e.c; ++C) {
        var cell = sheet[XLSX.utils.encode_cell({c:C, r:R})];
        var hdr = 'UNKNOWN ' + C;
        if(cell && cell.t) hdr = XLSX.utils.format_cell(cell);
        headers.push(hdr);
    }
    return headers;
  };

  my.extractData = function(sheet, headers) {
    var result = [];
    var range = XLSX.utils.decode_range(sheet['!ref']);
    var row = {};
    var C, R, value;

    for(R = range.s.r + 1; R <= range.e.r; ++R) {
      row = {};
      for(C = range.s.c; C <= range.e.c; ++C) {
        var cell = sheet[XLSX.utils.encode_cell({c:C, r:R})];
        if(cell && cell.t) value = XLSX.utils.format_cell(cell);
        row[headers[C]] = value;
      }
      result.push(row);
    }
    return result;
  };

}(DQ.backends.XLSX));


;/*global DQ: true*/
/* global Es2sql: true*/
/*global Cartodb: true*/

var Cartodb = {};
var privates = {};

(function(my) {
  'use strict';

  my.__type__ = 'cartodb';
  my.fetch = function (dataset) {
    var query, sql;
    var dfd = new DQ.Deferred();
    // parse user and query from url
    if (dataset.url) {
      dataset.user = privates._parseDatasetUrl(dataset.url);
      query = dataset.url.match(/q=(.*)/g);
      query = decodeURIComponent(query[0].replace('q=',''));
      console.log('cdbF0', query);
    // otherwise create a default query
    } else {
      query = dataset.query || privates._defaultQuery(dataset);
      query.table = dataset.table;
      query = Es2sql.translate(query);
    }
    sql = cartodb.SQL({ user: dataset.user });
    sql.execute(query).done(function (data) {
      var fields = _.keys(data.fields).map(function(val, i) {
        return {id: val};
      });
      dfd.resolve({
        fields: fields,
        rows:  data.rows,
        useMemoryStore: false
      });
    });
    return dfd.promise;
  };

  my.query = function (queryObj, dataset) {
   console.log('cdbQ0.0',queryObj, dataset);
   var query = {}, sql;
   var dfd = new DQ.Deferred;
   // if filters are present we need to do a query call to cartodb
    if (queryObj.filters && queryObj.filters.length > 0) {
      query.size = 100; 
      query.table = dataset.table || privates._parseTableName(dataset.url);
      query.filters = privates._mapQueryFilters(queryObj.filters); // we need to update filter format for Es2sql
      query = Es2sql.translate(query);
    } else  { // otherwise we are probably finishing the fetch call
      query = dataset.url.match(/q=(.*)/g);
      query = decodeURIComponent(query[0].replace('q=',''));
      console.log('cdbF0', query);
   }
   dataset.user = dataset.user ||  privates._parseDatasetUrl(dataset.url);
   console.log('cdbQ1', query);
   sql = cartodb.SQL({ user: dataset.user });
   sql.execute(query).done(function (data) {
     var fields = _.keys(data.fields).map(function(val, i) {
       return {id: val};
     });
     console.log('cdbQ3', data, fields);
     dfd.resolve({
       total: data.total_rows,
       hits: data.rows,
       fields: fields
     });
   });
   return dfd.promise;
 };

  privates._defaultQuery = function (dataset) {
    return {
      table: dataset.table,
      user: dataset.user,
      from: 0,
      size: 100
    }
  };

  // get tablename from url
  privates._parseTableName = function (url) {
    var s = url.match(/q=(.*)/g);
    console.log(s);
    s[0].replace('q=','');
    var reg = /(FROM )([^\s]+)/g;
    var t = reg.exec(decodeURIComponent(url));
    console.log('t',t[2]);
    return t[2];
  };

  // get username from url
  privates._parseDatasetUrl = function (url) {
    var s = url.replace(/http(s*):\/\//g, '');
    s = s.split('.')[0];
    console.log('>>',s);
    return s;
  };

  // filters should match format {type : {term : val}}
  // @@TODO maybe move this to es2sql lib
  privates._mapQueryFilters = function (filters) {
    var mapped = [];
    filters.forEach(function (filter) {
      // if it is defining type we need to remap
      if (filter['type']) {
        var mappedFilter = {};
        var type = filter.type;
        var field = filter.field;
        var term = filter.term;
        mappedFilter[type] = {};
        mappedFilter[type][field] = term;
        console.log('mf', JSON.stringify(mappedFilter));
        mapped.push(mappedFilter);
      } else {
        // otherwise we assume it's ok leave it alone
        mapped.push(filter);
      }
    });
    console.log(mapped);
    return mapped;
  };

  privates._mapQuery = function (query, dataset) {
    // get table name from dataset
    query.size = query.size || 100;
    query.from = query.from || 0;
    if (query.filters && query.filters.length > 0) {
      query.filters = privates._mapQueryFilters(query.filters);
    }
    return Es2sql.translate(query);
  };

})(Cartodb);

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.Cartodb = Cartodb;
;/*global DQ: true*/

var PapaCSV = {};

(function(my) {
  'use strict';
  my.__type__ = 'papacsv';

  my.fetch = function(dataset) {
    var dfd = new DQ.Deferred();
    var config = { complete: _.partial(my._complete, _, dfd, dataset)};

    if (dataset.file) {
      Papa.parse(dataset.file, config);
    } else if (dataset.data) {
      Papa.parse(dataset.data, config);
    } else if (dataset.url) {
      config.download = true;
      Papa.parse(dataset.url, config);
    }
    return dfd.promise;
  };

  my._complete = function(data, dfd, dataset){
    var out = my.extractFields(data.data, dataset);
    out.useMemoryStore = true;
    dfd.resolve(out);
  };

  // Convert array of rows in { records: [ ...] , fields: [ ... ] }
  // @param {Boolean} noHeaderRow If true assume that first row is not a header (i.e. list of fields but is data.
  my.extractFields = function(rows, noFields) {
    if (noFields.noHeaderRow !== true && rows.length > 0) {
      return {
        fields: rows[0],
        records: rows.slice(1)
      };
    } else {
      return {
        records: rows
      };
    }
  };

}(PapaCSV));

var DQ = DQ || {};
DQ.backends = DQ.backends || {};
DQ.backends.PapaCSV = PapaCSV;;/*jshint -W030 */

;(function(global, DQ){
  'use strict';

  /**********************
  *                     *
  *     AGGREGATIONS    *
  *                     *
  **********************/

  /**
   * Sum a field grouped by any field.
   */
  DQ.prototype._sum = function(resources, result, params){
    var self = this;

    return _.values(_.reduce(result, function(acum, record, index) {
      var gb = record[params.groupBy];
      var f = params.field;
      var as = params.as || f;
      var current = Number(record[f]);

      if (gb in acum) {
        acum[gb][as] = Number(acum[gb][as]) + current;
      } else {
        acum[gb] = record;
        acum[gb][as] = current;
      }
      return acum;
    }, {}));
  };

  /**
   * Avg of a field grouped by any field.
   */
  DQ.prototype._avg = function(resources, result, params){
    var self = this;
    var f = params.field;
    var as = params.as || 'avg';
    var previous;

    var precomputed = _.values(_.reduce(result, function(acum, record, index) {
      var gb = record[params.groupBy];
      var current = Number(record[f]);

      if (gb in acum) {
        previous = Number(acum[gb][f]);
        acum[gb].__total = Number(acum[gb].__total) + current;
        acum[gb].__count = previous + 1;
      } else {
        acum[gb] = record;
        acum[gb].__total = current;
        acum[gb].__count = 1;
      }
      return acum;
    }, {}));

    return _.map(precomputed, function(record, index) {
      record[as] = record.__total / record.__count;
      return _.omit(record, '__total', '__count');
    });
  };

  /**
   * Percentage of a field grouped by any field.
   */
  DQ.prototype._percentage = function(resources, result, params){
    var self = this;
    var f = params.field;
    var as = params.as || 'percentage';
    var previous;
    var total = 0;

    var precomputed = _.values(_.reduce(result, function(acum, record, index) {
      var gb = record[params.groupBy];
      var current = Number(record[f]);

      if (gb in acum) {
        acum[gb].__total = Number(acum[gb].__total) + current;
      } else {
        acum[gb] = record;
        acum[gb].__total = current;
      }
      total += current;
      return acum;
    }, {}));

    return _.map(precomputed, function(record, index) {
      record[as] = record.__total / total;
      return _.omit(record, '__total');
    });
  };

  /**
   * Max of a field grouped by any field.
   */
  DQ.prototype._max = function(resources, result, params){
    var self = this;

    return _.values(_.reduce(result, function(acum, record, index) {
      var gb = record[params.groupBy];
      var f = params.field;
      var as = params.as || f;
      var current = Number(record[f]);
      var previous;

      if (gb in acum) {
        previous = Number(acum[gb][as]);
        if (current > previous) {
          acum[gb][as] = current;
        }
      } else {
        acum[gb] = record;
        acum[gb][as] = current;
      }
      return acum;
    }, {}));
  };

  /**
   * Min of a field grouped by any field.
   */
  DQ.prototype._min = function(resources, result, params){
    var self = this;

    return _.values(_.reduce(result, function(acum, record, index) {
      var gb = record[params.groupBy];
      var f = params.field;
      var as = params.as || f;
      var current = Number(record[f]);
      var previous;

      if (gb in acum) {
        previous = Number(acum[gb][as]);
        if (current < previous) {
          acum[gb][as] = current;
        }
      } else {
        acum[gb] = record;
        acum[gb][as] = current;
      }
      return acum;
    }, {}));
  };

  /**
   * Count of a field grouped by any field.
   */
  DQ.prototype._count = function(resources, result, params){
    var self = this;

    return _.values(_.reduce(result, function(acum, record, index) {
      var gb = record[params.groupBy];
      var as = params.as || 'count';
      var previous;

      if (gb in acum) {
        previous = Number(acum[gb][as]);
        acum[gb][as] = previous + 1;
      } else {
        acum[gb] = record;
        acum[gb][as] = 1;
      }
      return acum;
    }, {}));
  };

})(window, DQ);;/*jshint -W030 */

;(function(global){
  'use strict';

  var castMap = {
    'string': String,
    'boolean': Boolean,
    'number': Number,
    'date': Date,
    'integer': parseInt,
    'float': parseFloat
  };

  DQ.__jsonpUnique = 0;


  DQ.cast = function(value, type){
    var rest = _.drop(_.toArray(arguments), 2);
    return castMap[type].apply(null, [value].concat(rest));
  };

  DQ.substr = function(value, start, end){
    return value.substring(start, end);
  };

  /**
   * Ajax calls using promises.
   * From https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
   */
  DQ.ajax = function(url){

    // A small example of object
    var core = {

      // Method that performs the ajax request
      ajax : function (method, url, args) {

        // Creating a promise
        var promise = new Promise( function (resolve, reject) {

          // Instantiates the XMLHttpRequest
          var client = new XMLHttpRequest();
          var uri = url;

          if (args && (method === 'POST' || method === 'PUT')) {
            uri += '?';
            var argcount = 0;
            for (var key in args) {
              if (args.hasOwnProperty(key)) {
                if (argcount++) {
                  uri += '&';
                }
                uri += encodeURIComponent(key) + '=' + encodeURIComponent(args[key]);
              }
            }
          }
          client.open(method, uri, true);
          client.send();

          client.onload = function () {
            if (Number(client.status) === 200) {
              // Performs the function "resolve" when this.status is equal to 200
              resolve(client.response);
            } else {
              // Performs the function "reject" when this.status is different than 200
              reject(client.statusText);
            }
          };
          client.onerror = function () {
            reject(client.statusText);
          };
        });

        // Return the promise
        return promise;
      }
    };

    // Adapter pattern
    return {
      'get' : function(args) {
        return core.ajax('GET', url, args);
      },
      'post' : function(args) {
        return core.ajax('POST', url, args);
      },
      'put' : function(args) {
        return core.ajax('PUT', url, args);
      },
      'delete' : function(args) {
        return core.ajax('DELETE', url, args);
      }
    };
  };

  /**
   * Gets a cross-domain json
   * @param  {String} url
   * @return {Promise}
   * https://gist.github.com/132080/110d1b68d7328d7bfe7e36617f7df85679a08968
   */
  DQ.jsonp = function(url, errorTimeout) {
    var promise = new Promise( function (resolve, reject) {

      var name = '_jsonp_' + DQ.__jsonpUnique++;
      var paramGlue = url.match(/\?/) ? '&' : '?';
      var script;
      var timeout;

      // Append callback function to the url
      url +=  paramGlue + 'callback=' + name;

      // Create script
      script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = url;

      timeout = setTimeout(function(){
        reject({error: 'Request timeout'});
      }, errorTimeout || 5000);

      // Setup handler
      window[name] = function(data){
        resolve(data);
        window.clearTimeout(timeout);
        document.getElementsByTagName('head')[0].removeChild(script);
        script = null;
        delete window[name];
      };

      // Load JSON
      document.getElementsByTagName('head')[0].appendChild(script);
    });
    return promise;
  };

  /**
   * Deferred polyfill
   * From https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
   */
  DQ.Deferred = function () {
    if (typeof Promise !== 'undefined' && Promise.defer) {
      return Promise.defer();
    } else if (typeof PromiseUtils !== 'undefined' && PromiseUtils.defer) {
      return PromiseUtils.defer();
    } else {
      try {
        this.resolve = null;
        this.reject = null;

        this.promise = new Promise(function(resolve, reject) {
          this.resolve = resolve;
          this.reject = reject;
        }.bind(this));
        Object.freeze(this);
      } catch (ex) {
        throw new Error('Promise/Deferred is not available');
      }
    }
  };

})(window);;/*jshint -W030 */

;(function(global, DQ){
  'use strict';
  DQ.fmt = {};

  DQ.fmt.toCSV = function(data) {
    var fields = _.map(_.keys(_.first(data)), function(field){
      return {id: field};
    });
    return CSV.serialize({
      fields: fields,
      records: data
    });
  };

})(window, DQ);